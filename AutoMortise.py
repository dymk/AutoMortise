# Author-dymk
# Description-Create various joints

import adsk.core
import adsk.fusion
import adsk.cam
import traceback
import logging
import sys
import itertools
from . import ids
from . import geom
from .boundary import boundary
import timeit

EPS = 0.00001
DEBUGGING_GRAPHICS = False
MOAR_DEBUG = False
handlers = []


def createHandler(klass, method, name):
    class _Handler(klass):
        def __init__(self):
            super().__init__()
            print("initialized {} handler".format(name))

        def notify(self, arg):
            print("handler {} called".format(name))
            method(arg)

    handler = _Handler()
    handlers.append(handler)
    return handler


class AutoMortiseCommand():
    def __init__(self, createHandler):
        self._createHandler = createHandler

    @boundary("onCreate")
    def onCreate(self, args: adsk.core.CommandCreatedEventArgs):
        command = args.command
        inputs = command.commandInputs

        self._bodies: List[adsk.fusion.BRepBody] = []
        self._inputs: List[adsk.core.SelectionCommandInput] = []

        self._inputs.append(inputs.addSelectionInput(
            ids.BODIES_SELECT, 'Bodies',
            'Select bodies to generate tabs between'
        ))

        for _input in self._inputs:
            _input.addSelectionFilter('SolidBodies')
            _input.setSelectionLimits(2, 0)

        command.inputChanged.add(self._createHandler(
            adsk.core.InputChangedEventHandler,
            self.onChange,
            "onChange"
        ))

        command.validateInputs.add(self._createHandler(
            adsk.core.ValidateInputsEventHandler,
            self.onValidate,
            "onValidate"
        ))

        command.execute.add(self._createHandler(
            adsk.core.CommandEventHandler,
            self.onExecute,
            "onExecute"
        ))

    @boundary("onChange")
    def onChange(self, args: adsk.core.InputChangedEventArgs):
        input_ = adsk.core.SelectionCommandInput.cast(args.input)
        if input_.id == ids.BODIES_SELECT:
            entities = [
                input_.selection(idx).entity
                for idx in range(input_.selectionCount)
            ]
            self._bodies = entities
            print("{} bodies selected".format(len(entities)))

    @boundary("onValidate")
    def onValidate(self, args: adsk.core.ValidateInputsEventArgs):
        return len(self._bodies) >= 2

    def app(self):
        return adsk.core.Application.get()

    def design(self):
        return adsk.fusion.Design.cast(self.app().activeProduct)

    def rootComponent(self):
        return self.design().rootComponent

    @boundary("onExecute")
    def onExecute(self, args: adsk.core.CommandEventArgs):
        pairsOfBodies = list(itertools.combinations(self._bodies, 2))
        print("{} combinations of bodies".format(len(pairsOfBodies)))

        # for now, remove any existing history groups generated by this script
        existingGroups = geom.adskList(
            self.design().timeline.timelineGroups,
            adsk.fusion.TimelineGroup
        )

        for g in existingGroups:
            if g.name == ids.TAB_TIMELINE_GROUP:
                g.deleteMe(True)

        tlstart = self.design().timeline.markerPosition

        startTimeFindCandidates = timeit.default_timer()
        tabsToExtrude = []
        for bodyPair in pairsOfBodies:
            for facePair in self.getCandidateFacePairs(*bodyPair):
                tabToExtrude = self.tryPlacingTabProfiles(*facePair)
                if tabToExtrude is not None:
                    tabsToExtrude.append(tabToExtrude)
        endTimeFindCandidates = timeit.default_timer()

        startTimeExtrude = timeit.default_timer()
        for tabToExtrude in tabsToExtrude:
            self.extrudeTabs(*tabToExtrude)
        endTimeExtrude = timeit.default_timer()

        def timeFmt(dur):
            return "{} seconds".format(round(dur, 2))

        print("duration to get candidate pairs: {}".format(
            timeFmt(endTimeFindCandidates - startTimeFindCandidates)))
        print("duration to extrude profiles:    {}".format(
            timeFmt(endTimeExtrude - startTimeExtrude)))

        tlend = self.design().timeline.markerPosition-1
        if (tlend - tlstart) > 0:
            group = self.design().timeline.timelineGroups.add(tlstart, tlend)
            group.name = ids.TAB_TIMELINE_GROUP

    # tries to extrude tabs from fromFace into toFace
    # If the operation fails, then returns None
    # If it works, returns information about how to extrude the tab later
    def tryPlacingTabProfiles(self, fromFace: adsk.fusion.BRepFace, toFace: adsk.fusion.BRepFace) -> bool:
        ac = fromFace.assemblyContext
        if ac:
            component = ac.component
        else:
            component = self.rootComponent()
        component = adsk.fusion.Component.cast(component)

        prettyName = "{} -> {}".format(fromFace.body.name, toFace.body.name)
        print("Checking if candidate pair of faces between {} is valid".format(
            prettyName))

        sketchName = ids.TAB_SKETCH_PREFIX + prettyName
        sketch = component.sketches.addWithoutEdges(fromFace)
        sketch.name = sketchName
        sketch.isComputeDeferred = True

        toEvaluator = toFace.evaluator
        for vertex in geom.adskList(fromFace.vertices, adsk.fusion.BRepVertex):
            success, vertexParam = toEvaluator.getParameterAtPoint(
                vertex.geometry
            )
            if not success or not toEvaluator.isParameterOnFace(vertexParam):
                print("({}, {}) does not lie on the target surface".format(*[
                    round(i, 2) for i in [vertex.geometry.x, vertex.geometry.y]
                ]))
                sketch.deleteMe()
                return None

        # check that the face is some sort of rectangle - and get the basis vector for its
        # orientation
        fromEdges = geom.adskList(fromFace.edges, adsk.fusion.BRepEdge)

        for edge in fromEdges:
            if edge.geometry.curveType != adsk.core.Curve3DTypes.Line3DCurveType:
                print("Face between {} contains a non-straight line".format(prettyName))
                sketch.deleteMe()
                return None

        sketch.isComputeDeferred = False
        fromEdgesOnSketch = []
        for edge in fromEdges:
            collection = sketch.project(edge)
            for i in range(collection.count):
                sketchCurve = collection.item(i)
                sketchCurve.isConstruction = True
                fromEdgesOnSketch.append(sketchCurve)
        sketch.isComputeDeferred = True

        edgeDirs = []
        edgeGroups = []
        fromEdgesOnSketch.sort(key=geom.edgeDirectionForComparison)
        for edgeDir, edges in itertools.groupby(fromEdgesOnSketch, key=geom.edgeDirectionForComparison):
            edgeDirs.append(edgeDir)
            edgeGroups.append(list(edges))

        if len(edgeDirs) != 2:
            print("Face must be a rectangle ({} edge directions detected: {})".format(
                len(edgeDirs), edgeDirs))
            sketch.deleteMe()
            return None

        if abs(geom.edgeDirection(edgeGroups[0][0]).dotProduct(geom.edgeDirection(edgeGroups[1][0]))) >= EPS:
            print("Face must be a rectangle (nonorthonal edge directions detected)")
            sketch.deleteMe()
            return None

        # find all the coplanar faces on the body being extruded into,
        # and find the farthest one from fromFace
        toBodyFaces = sorted([
            face
            for face
            in geom.adskList(toFace.body.faces, adsk.fusion.BRepFace)
            if not toFace == face and geom.arePlanesParallel(toFace, face)
        ], key=lambda face: -geom.distBetweenFaces(fromFace, face))

        if len(toBodyFaces) == 0:
            print("body to extrude into has no good candidate ending plane")
            sketch.deleteMe()
            return None

        toBodyTargetFace = toBodyFaces[0]

        # find the longer of the edges
        longEdges: List[adsk.fusion.SketchLine] = max(
            edgeGroups, key=lambda group: geom.sketchLineLength(group[0])
        )

        # start / end points of the two long sides
        e1points = [
            longEdges[0].geometry.startPoint,
            longEdges[0].geometry.endPoint
        ]
        e2points = [
            longEdges[1].geometry.startPoint,
            longEdges[1].geometry.endPoint
        ]

        # the start / end points might be swapped - starting points should be closer to each other
        if(geom.distToPoint(e1points[0], e2points[0]) > geom.distToPoint(e1points[0], e2points[1])):
            e2points.reverse()

        def drawRectFrom(lower, upper):
            # points of a polygon representing a rectangle
            rectPoints = [
                geom.lerp(e1points[0], e1points[1], lower),
                geom.lerp(e1points[0], e1points[1], upper),
                geom.lerp(e2points[0], e2points[1], upper),
                geom.lerp(e2points[0], e2points[1], lower)
            ]

            for idx, p1 in enumerate(rectPoints):
                p2 = rectPoints[(idx + 1) % len(rectPoints)]
                sketch.sketchCurves.sketchLines.addByTwoPoints(
                    p1, p2
                )

        # TODO: generate variable number of tabs of reasonable size, within some upper/lower bound
        # For now just put two tabs in sensible looking places
        drawRectFrom(0.2, 0.4)
        drawRectFrom(0.6, 0.8)

        sketch.isComputeDeferred = False
        print("{} sketch profiles generated".format(sketch.profiles.count))
        tabProfiles = adsk.core.ObjectCollection.create()
        for profile in geom.adskList(sketch.profiles, adsk.fusion.Profile):
            tabProfiles.add(profile)

        tabDist = geom.distBetweenFaces(fromFace, toBodyTargetFace)

        # The plane to extrude from, the tab profiles to extrude, the distance to extrude the tabs
        # and the two bodies that will be extrude from / into
        return (fromFace.geometry, tabProfiles, tabDist, fromFace.body, toFace.body)

    def extrudeTabs(
        self,
        plane: adsk.core.Plane,
        profilesCollection: adsk.core.ObjectCollection,
        tabDist: float,
        fromBody: adsk.fusion.BRepBody,
        toBody: adsk.fusion.BRepBody
    ):
        fromComponent = self.getComponentOrRoot(fromBody)
        toComponent = self.getComponentOrRoot(toBody)

        # perform the tab extrude (only on the body that contains the fromFace)
        tabFeatureInput = fromComponent.features.extrudeFeatures.createInput(
            profilesCollection, adsk.fusion.FeatureOperations.JoinFeatureOperation
        )
        tabFeatureInput.participantBodies = [fromBody]
        tabFeatureInput.setDistanceExtent(
            False, adsk.core.ValueInput.createByReal(tabDist))
        fromComponent.features.extrudeFeatures.add(tabFeatureInput)

        # and cut tabs into the other body
        cutFeatureInput = toComponent.features.extrudeFeatures.createInput(
            profilesCollection, adsk.fusion.FeatureOperations.CutFeatureOperation
        )
        cutFeatureInput.participantBodies = [toBody]
        cutFeatureInput.setDistanceExtent(
            False, adsk.core.ValueInput.createByReal(tabDist))
        toComponent.features.extrudeFeatures.add(cutFeatureInput)

    def getComponentOrRoot(self, objWithAssemblyContext) -> adsk.fusion.Component:
        ac = objWithAssemblyContext.assemblyContext
        if ac:
            return ac.component
        else:
            return self.rootComponent()

    def getCandidateFacePairs(
        self,
        body1: adsk.fusion.BRepBody,
        body2: adsk.fusion.BRepBody
    ) -> (adsk.fusion.BRepFace, adsk.fusion.BRepFace):
        def doFaceEachOther(f1, f2):
            # if n1+n2 == 0, they're complementary vectors
            v1 = geom.faceNormal(f1)
            v2 = geom.faceNormal(f2)
            v1.add(v2)
            return v1.length < EPS

        # [0] - the smaller brep face (gets notches extruded from)
        # [1] - the larger brep face (gets cut into)
        candidatePairs: (adsk.fusion.BRepFace, adsk.fusion.BRepFace) = []
        for f1 in body1.faces:
            for f2 in body2.faces:

                coplanar = geom.areFacesCoplanar(f1, f2)
                if coplanar and MOAR_DEBUG:
                    print("these planes are coplanar:    {}, {}".format(
                        f1.tempId, f2.tempId))

                faceEachOther = doFaceEachOther(f1, f2)
                if faceEachOther and MOAR_DEBUG:
                    print("these planes face each other: {}, {}".format(
                        f1.tempId, f2.tempId))

                if coplanar and faceEachOther:
                    candidatePairs.append(
                        (f1, f2) if f1.area < f2.area else (f2, f1)
                    )

        return candidatePairs


def tryRemove():
    app = adsk.core.Application.get()
    ui = app.userInterface
    cmdDef = ui.commandDefinitions.itemById(ids.MAIN_BUTTON_ID)
    if cmdDef:
        cmdDef.deleteMe()
    createPanel = ui.allToolbarPanels.itemById('SolidCreatePanel')
    cntrl = createPanel.controls.itemById(ids.MAIN_BUTTON_ID)
    if cntrl:
        cntrl.deleteMe()

    root = adsk.fusion.Design.cast(app.activeProduct).rootComponent

    if root.customGraphicsGroups.count > 0:
        root.customGraphicsGroups.item(0).deleteMe()
        app.activeViewport.refresh()

    print("removed def: {}".format(
        cmdDef is not None))
    print("removed ctrl: {}".format(
        cntrl is not None))


@boundary("run")
def run(context):
    tryRemove()
    app = adsk.core.Application.get()
    ui = app.userInterface
    command = AutoMortiseCommand(createHandler)
    handlers.append(command)

    button = ui.commandDefinitions.addButtonDefinition(
        ids.MAIN_BUTTON_ID,
        'AutoMortise',
        'Generate mortise&tenon / box joints',
        'res'
    )

    button.commandCreated.add(createHandler(
        adsk.core.CommandCreatedEventHandler,
        command.onCreate,
        "onCreate"
    ))

    createPanel = ui.allToolbarPanels.itemById('SolidCreatePanel')
    buttonControl = createPanel.controls.addCommand(
        button,
        ids.MAIN_BUTTON_ID
    )

    # Make the button available in the panel.
    buttonControl.isPromotedByDefault = True
    buttonControl.isPromoted = True
    print("started addin")


@boundary("stop")
def stop(context):
    tryRemove()
    print("stopped addin")
